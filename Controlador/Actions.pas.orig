unit Actions;

{$mode objfpc}{$H+}

interface

uses Graphics,Main,Param,Math,DecConsts,ObsAvoid,SysUtils;

const
  IDCTRL_OMNI_FORWARD=1;
  IDCTRL_OMNI_POSITION=2;
  IDCTRL_OMNI_XYTETA=3;

type
  TAction=(acStop, acGoToXYTeta,acAdvisedSpeed);

const
  CActionString: array[low(TAction)..High(TAction)] of string =
        ('acStop','acGoToXYTeta','acAdvisedSpeed');

const
  GoToXYTetaPrecision=0.025;

procedure ActionStop(num: integer);
procedure ActionGoToXYTeta(num: integer);
procedure ActionAdvisedSpeed(num: integer);
procedure VVnToVxy(teta,v,vn: double; var Vx,Vy: double);

type
  TActionFunc = procedure(num: integer);

const
  CActionFunc: array[low(TAction)..High(TAction)] of TActionFunc =
      ( @ActionStop, @ActionGoToXYTeta,@ActionAdvisedSpeed);

type
  TActionPars=record
    x,y,w,teta: double;

    sx,sy: double;    // start position for acFollowVector

    anyway: boolean;
    speed: double;
    speed_on_target: double;
    target_precision: double;

    chipkick_dist: double;
    avoid: TAvoidSet;
  end;

var
  ActionPars: array [0..MaxRobots-1] of TActionPars;
  traj: TTrajectory;
  olddist: double;



function ActionString(a: TAction): string;

implementation

uses Tactic, Utils, Robots, Roles, Tasks;

function ActionString(a: TAction): string;
begin
  result:=CActionString[a];
end;

//----------------------------------------------------------------------
//  Controller

function SatVal(v, vmax: double): double;
begin
  if v > vmax then v := vmax;
  if v < -vmax then v := -vmax;
  result := v;
end;

procedure ProportionalSat(var v1,v2,v3: double; vmax: double);
var maxv,minv: double;
    scale,scalemax,scalemin: double;
begin
  // conversao de velocidade linear para a maxima na roda
  vmax:=0.87*vmax;

  maxv:=Max(abs(v1),Max(abs(v2),abs(v3)));

  if maxv>vmax then
    scale:=maxv/vmax
  else
    scale:=1;

  v1:=v1/scale;
  v2:=v2/scale;
  v3:=v3/scale;
end;

procedure SetTacticCommandsInRobotRef(var com: TTacticCommand; v,vn,w: double);
begin
  com.v:=v;
  com.vn:=vn;
  com.w:=w;
  with com do begin
    v1 := v * MechCosAlpha + vn * MechSinAlpha + MechD * w;
    v2 := -v * MechCosAlpha + vn * MechSinAlpha + MechD * w;
    v3 := -vn + MechB * w;
    ProportionalSat(v1, v2, v3, SpeedMax);
  end;
end;

procedure VxyToVVn(teta,vx,vy: double; var V,Vn: double);
var ct,st: double;
begin
  ct:=cos(teta);
  st:=sin(teta);
  v:=vx*ct+vy*st;
  vn:=-vx*st+vy*ct;
end;

procedure ActionAdvisedSpeed(num: integer);
var advV,advVn,advW:double;
begin
  advV:=RobotState[num].LocAdvV;
  advVn:=RobotState[num].LocAdvVn;
  advW:=RobotState[num].LocAdvW;

  SetTacticCommandsInRobotRef(TacticCommands[num],advV,advVn,advW);
end;

procedure VVnToVxy(teta,v,vn: double; var Vx,Vy: double);
var ct,st: double;
begin
  ct:=cos(teta);
  st:=sin(teta);
  vx:=v*ct-vn*st;
  vy:=v*st+vn*ct;
end;

procedure TrajectoryController(speed, speed_on_target: double; var state: TRobotState; var com: TTacticCommand; var traj: TTrajectory;tgx,tgy: double);
var statev, statevn, v, vn, dteta, derdist,distancia,stopang: double;
    vmax, pw, tx, ty, tempx,tempy, segteta, deltat, vball: double;
    idx: integer;
begin
  idx := Min(3, traj.count-1);
  tx := traj.pts[idx].x;
  ty := traj.pts[idx].y;
  dteta := DiffAngle(traj.pts[idx].teta, state.teta);

  segteta := ATan2(ty-state.y,tx-state.x);

  distancia:=dist((tgx-state.x),(tgy-state.y));

  tempx:=tx-state.x;
  tempy:=ty-state.y;
  NormalizeVector(tempx,tempy);

  if (traj.distance < deltadist) then begin
    vmax := 0;
  end else begin
    if (distancia>1.75) then begin
       vmax := speed;
    end else if (distancia>0.8)and(distancia<=1.75) then begin
       vmax := (speed_on_target) +  (1.6)*(traj.distance);
    end else if (distancia>0.10)and(distancia<=0.8) then begin
       vmax := (speed_on_target) +  (1.2)*(traj.distance);
    end else if (distancia<=0.10) then begin
        vmax := (speed_on_target) + (0.8)*(traj.distance);
    end;
  end;
  tempx:=tempx*vmax;
  tempy:=tempy*vmax;
  if vmax>speed then vmax:=speed;
  VxyToVVn(state.teta, tempx, tempy, v, vn);

  if abs(dteta) < deltateta * Pi / 180 then begin
    pw := 0;
  end else begin
    pw := 3 * dteta - 0.5 * state.sw;
  end;

  SetTacticCommandsInRobotRef(com, v, vn, pw);
end;

procedure TrajectoryControllerAtack(speed, speed_on_target: double; var state: TRobotState; var com: TTacticCommand; var traj: TTrajectory;tgx,tgy: double);
var statev, statevn, v, vn, dteta, derdist,distancia,stopang: double;
    vmax, pw, tx, ty, tempx,tempy, segteta, deltat, vball: double;
    idx: integer;
begin
  idx := Min(3, traj.count-1);
  tx := traj.pts[idx].x;
  ty := traj.pts[idx].y;
  dteta := DiffAngle(traj.pts[idx].teta, state.teta);

  segteta := ATan2(ty-state.y,tx-state.x);

  distancia:=dist((tgx-state.x),(tgy-state.y));
  vball:=sqrt(sqr(BallState.vx)+sqr(BallState.vy));

  tempx:=tx-state.x;
  tempy:=ty-state.y;
  NormalizeVector(tempx,tempy);

  if (traj.distance < deltadist) then begin
    vmax := 0;
  end else begin
    if (distancia>1.75) then begin
       vmax := speed;
    end else if (distancia>0.8)and(distancia<=1.75) then begin
       vmax := (speed_on_target) +  (1.8)*(traj.distance);
    end else if (distancia>0.10)and(distancia<=0.8) then begin
       vmax := (speed_on_target) +  (1.4)*(traj.distance);
    end else if (distancia<=0.10) then begin
        vmax := (speed_on_target) + (1.0)*(traj.distance);
    end;
  end;
  tempx:=tempx*vmax;
  tempy:=tempy*vmax;
  if vmax>speed then vmax:=speed;
  VxyToVVn(state.teta, tempx, tempy, v, vn);

  if abs(dteta) < deltateta * Pi / 180 then begin
    pw := 0;
  end else begin
    pw := 3 * dteta - 0.5 * state.sw;
  end;

  SetTacticCommandsInRobotRef(com, v, vn, pw);
end;


//----------------------------------------------------------------------
//  Actions

procedure ActionStop(num: integer);
begin
  with TacticCommands[num] do begin
    v1:=0;
    v2:=0;
    v3:=0;
    v:=0;
    vn:=0;
    w:=0;
  end;
  RobotCalcData[num].trajectory_length := 0;
end;

procedure ActionGoToXYTeta(num: integer);
var rx,ry,d: double;
    i: integer;
begin
  rx:=ActionPars[num].x;
  ry:=ActionPars[num].y;


  RobotBestPath(num,rx,ry,traj,ActionPars[num].avoid);


  for i:=0 to traj.count - 1 do begin
    traj.pts[i].teta := ActionPars[num].teta;
    traj.pts[i].teta_power := 1;
  end;

  if RobotInfo[num].task=taskGoToBall then begin
     //Controle do Miguel
  end else if RobotInfo[num].task=taskCatchBall then begin
     TrajectoryControllerAtack(ActionPars[num].speed, ActionPars[num].speed_on_target, RobotState[num], TacticCommands[num], traj,rx,ry);
  end else begin
     TrajectoryController(ActionPars[num].speed, ActionPars[num].speed_on_target, RobotState[num], TacticCommands[num], traj,rx,ry);
  end;

  RobotCalcData[num].trajectory_length := traj.distance;
end;

end.



